name: Deploy Infrastructure

on:
  push:
    branches: [ main ]
    paths:
      - 'terraform/**'
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  # Terraform will automatically pick up env vars starting with TF_VAR_
  TF_VAR_admin_role_name: ${{ secrets.TF_VAR_ADMIN_ROLE_NAME }}
  TF_VAR_github_repo: ${{ vars.GITHUB_REPO }}
  TF_VAR_image_repo_name: ${{ vars.ECR_IMAGE_REPO }}
  TF_VAR_signature_repo_name: ${{ vars.ECR_SIG_REPO }}

jobs:
  ensure-backend:
    name: Ensure Backend Exists
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure S3 Bucket
        run: |
          BUCKET_NAME="${{ secrets.TF_STATE_BUCKET }}"
          REGION="${{ env.AWS_REGION }}"
          
          if [[ -z "$BUCKET_NAME" ]]; then
            echo "Error: TF_STATE_BUCKET secret is not set."
            exit 1
          fi

          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "Bucket $BUCKET_NAME already exists."
          else
            echo "Creating bucket $BUCKET_NAME..."
            if [ "$REGION" == "us-east-1" ]; then
              aws s3 mb "s3://$BUCKET_NAME"
            else
              aws s3 mb "s3://$BUCKET_NAME" --region "$REGION"
            fi
            
            # 1. Enable Versioning
            aws s3api put-bucket-versioning --bucket "$BUCKET_NAME" --versioning-configuration Status=Enabled
            
            # 2. Enable Encryption (AES256)
            aws s3api put-bucket-encryption --bucket "$BUCKET_NAME" --server-side-encryption-configuration '{"Rules": [{"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]}'
            
            # 3. Block All Public Access
            aws s3api put-public-access-block --bucket "$BUCKET_NAME" --public-access-block-configuration "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
            
            # 4. Enforce SSL via Bucket Policy
            POLICY=$(echo '{
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Sid": "EnforceTLS",
                  "Effect": "Deny",
                  "Principal": "*",
                  "Action": "s3:*",
                  "Resource": [
                    "arn:aws:s3:::'"$BUCKET_NAME"'",
                    "arn:aws:s3:::'"$BUCKET_NAME"'/*"
                  ],
                  "Condition": {
                    "Bool": {
                      "aws:SecureTransport": "false"
                    }
                  }
                }
              ]
            }')
            aws s3api put-bucket-policy --bucket "$BUCKET_NAME" --policy "$POLICY"
          fi

      - name: Ensure DynamoDB Table
        run: |
          TABLE_NAME="${{ secrets.TF_STATE_DYNAMODB_TABLE }}"
          REGION="${{ env.AWS_REGION }}"

          if [[ -z "$TABLE_NAME" ]]; then
            echo "Error: TF_STATE_DYNAMODB_TABLE secret is not set."
            exit 1
          fi

          if aws dynamodb describe-table --table-name "$TABLE_NAME" --region "$REGION" 2>/dev/null; then
             echo "Table $TABLE_NAME already exists."
          else
             echo "Creating table $TABLE_NAME..."
             aws dynamodb create-table \
                --table-name "$TABLE_NAME" \
                --attribute-definitions AttributeName=LockID,AttributeType=S \
                --key-schema AttributeName=LockID,KeyType=HASH \
                --billing-mode PAY_PER_REQUEST \
                --ss-specification Enabled=true \
                --region "$REGION"
             
             # Wait for table to be active before updating
             aws dynamodb wait table-exists --table-name "$TABLE_NAME" --region "$REGION"

             # Enable Point-in-Time Recovery
             aws dynamodb update-continuous-backups \
                --table-name "$TABLE_NAME" \
                --point-in-time-recovery-specification PointInTimeRecoveryEnabled=true \
                --region "$REGION"
          fi

  terraform:
    name: Terraform Apply
    needs: ensure-backend
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./terraform
    
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          # You need a role that has permissions to create IAM roles, ECR repos, and KMS keys
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=ecr-signing-pipeline/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_DYNAMODB_TABLE }}"

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        run: terraform plan -input=false

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'
        run: terraform apply -auto-approve -input=false
